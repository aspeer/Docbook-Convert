#!/bin/perl
#
use strict qw(vars);
use lib qw(lib);
use vars qw($VERSION);



#  External modules
#
use IO::File;
use Getopt::Long;
Getopt::Long::Configure('no_ignore_case');
use Pod::Usage;
use FindBin qw($RealBin $Script);
use File::Find;
use Cwd qw(cwd abs_path);
use Docbook::Convert;
use Docbook::Convert::Util;
use Docbook::Convert::POD::Util;
use Docbook::Convert::Constant;


#  Used for debugging only
#
use Data::Dumper;
$Data::Dumper::Indent=1;
$Data::Dumper::Terse=1;


#  Version Info, must be all one line for MakeMaker, CPAN.
#
$VERSION='0.001';


#  Run main routine
#
exit ${&main(&getopt(\@ARGV)) || die 'unknown error'};


#===================================================================================================

sub getopt {


    #  Parse options and dispatch to actual work routine below
    #
    my $argv_ar=shift();
    
    
    #  Get options
    #
    my %opt;
    
    
    #  Converts some constant settings into settable options
    #
    my @getopt_constant=map { $GETOPT_CONSTANT_HR->{$_} ? $_.$GETOPT_CONSTANT_HR->{$_} : $_ } 
        keys %{$GETOPT_CONSTANT_HR};


    #  Get command line options
    #
    GetOptions(
        \%opt,
        @{$GETOPT_AR},
        @getopt_constant,
    ) || pod2usage(2);
    pod2usage(-verbose => 99, -sections => 'Synopsis|Options', -exitval => 1) if $opt{'help'};
    pod2usage(-verbose => 2) if $opt{'man'};
    $opt{'version'} && do {
        print "$Script version: $VERSION\n";
        exit 0
    };
    
    
    #  Debug
    #
    $opt{'dumpopt'} && do {
        print Dumper([sort @{$GETOPT_AR}, @getopt_constant]);
        exit 0;
    };
    

    #  And set any constants based on options supplied
    #
    foreach my $opt (keys %{$GETOPT_CONSTANT_HR}) {
        if (defined($opt{$opt})) {
            ${uc($opt)}=$opt{$opt};
        }
    }


    # Recursing ?
    #
    if (exists $opt{'recurse'} || $opt{'recursedir'}) {
        my $dn=$opt{'recursedir'} || cwd();
        $dn=Cwd::abs_path($dn);
        my @fn;
        my $wanted_cr=sub {
            return unless -f (my $fn=$File::Find::name);
            return if $fn=~/\/\._/;    #  Mac temp file
            push @fn, $fn if ($fn=~/\Q$XMLSUFFIX\E$/);
        };
        find($wanted_cr, $dn);
        @fn ||
            return err ("no files with '%s' suffix found when recursing directory '$dn'", $XMLSUFFIX);
        $opt{'infile'}=\@fn;
    }


    #  Get infile
    #
    unless (@{$opt{'infile'}}) {
        $opt{'infile'}=@{$argv_ar} ? $argv_ar : [\*STDIN];
    }
    
    
    #  Set handler
    #
    $opt{'handler'} ||= (
        ($opt{'markdown'} && 'markdown') ||
        ($opt{'pod'} && 'pod') ||
        $HANDLER_DEFAULT
    );
    

    #  Done
    #
    return \%opt;

}


sub main {

    #  Passed a list of options and convert file/input stream
    #
    my $opt_hr=shift();
    foreach my $fn (@{$opt_hr->{'infile'}}) {
        my $output;
        if (ref($fn) eq 'GLOB') {
            $output=Docbook::Convert->process($fn, $opt_hr);
        }
        else {
            $output=Docbook::Convert->process_file($fn, $opt_hr);
        }
        if ($opt_hr->{'merge'}) {
            (my $out_fn=$fn)=~s/\Q$XMLSUFFIX\E$//;
            unless (-f $out_fn) {
                return err ("can't merge into file '$out_fn', file does not exist");
            }
            Docbook::Convert::POD::Util->_pod_replace($out_fn, \$output);
        }
        elsif (my $out_fn=$opt_hr->{'outfile'}) {
            if ($out_fn=~/^\.(.*)$/) {
                #  Output file option is something like '.foo'. Means add '.foo' to input file name
                #  and make that the output file name
                #
                my $ext=$1;
                ($out_fn=$fn)=~s/\Q$XMLSUFFIX\E$//;
                $out_fn.=".${ext}";
            }
            my $out_fh=IO::File->new($out_fn, O_WRONLY|O_CREAT|O_TRUNC) ||
                return err("unable to write to output file $out_fn, $!");
            print $out_fh $output;
        }
        else {
            print $output;
        }
    }
    return \undef;
    
}

